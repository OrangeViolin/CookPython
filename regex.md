# 正则表达式（未完）

## 正则表达式就是筛子

你大可以把正则表达式想象成一个筛子。你要去海量的字符串中去筛选你想要的东西，你要为你想要的量身打造一个筛子。

配上官方介绍：

正则表达式(regular expression)描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。

## 你要知道可以用哪些材料

你要知道如何来打造一个筛子。

配上官方介绍：

构造正则表达式的方法和创建数学表达式的方法一样。也就是用多种元字符与运算符可以将小的表达式结合在一起来创建更大的表达式。正则表达式的组件可以是单个的字符、字符集合、字符范围、字符间的选择或者所有这些组件的任意组合。

正则表达式是由普通字符（例如字符 a 到 z）以及特殊字符（称为"元字符"）组成的文字模式。模式描述在搜索文本时要匹配的一个或多个字符串。正则表达式作为一个模板，将某个字符模式与所搜索的字符串进行匹配。

匹配一个字符：

- \d 可以匹配任意一个数字
- \w 可以匹配任意一个字母
- \s可以匹配一个空格
- . 可以匹配任意一个字符

限定匹配的数量

- * 匹配任意个字符，包括0个
- + 匹配任意个字符，不包括0个
- 用？表示0个或1个字符
- {m}表示匹配m个字符
- {n，m}表示 n-m个字符

其他更加精准匹配 [ ]表示范围，可以在 [ ]对你想要匹配的一个字符尽可能精准描述

- [0-9a-zA-Z\_]可以匹配一个数字、字母或者下划线
- [0-9a-zA-Z\_]+可以匹配至少由一个数字、字母或者下划线组成的字符串，比如'a100'，'0_Z'，'Py3000'等等
- [a-zA-Z\*][0-9a-zA-Z\*]*可以匹配由字母或下划线开头，后接任意个由一个数字、字母或者下划线组成的字符串，也就是Python合法的变量
- [a-zA-Z\*][0-9a-zA-Z\*]{0, 19}更精确地限制了变量的长度是1-20个字符（前面1个字符+后面最多19个字符）

A|B可以匹配A或B，所以(P|p)ython可以匹配'Python'或者'python'

^表示行的开头，^\d表示必须以数字开头

$表示行的结束，\d$表示必须以数字结束

你可能注意到了，py也可以匹配'python'，但是加上^py$就变成了整行匹配，就只能匹配'py'了

### 一个容易出错的地方

在 python 当中，\有特殊的转义的意义，但在正则表达式当中，\也是经常用到的，为了防止弄混，在写函数的时候，往往加上一个 r”有了这个，就等于告诉计算机，我现在是在编筛子不是在其他的，双引号中的所有命令都给我用正则的命令。

一个编筛子的练习场

[Online regex tester and debugger: PHP, PCRE, Python, Golang and JavaScript](https://regex101.com/)

![](Untitled-ba8ac2fe-bc35-4464-a9b7-2fcd21e7c70e.png)

可以显示出你的每一个正则表达式的匹配含义，还能给你做结构分析。

附上常见字符

[Untitled](https://www.notion.so/dc41e80147f642d6a7cea0ddaff07c8e)

[常用正则表达式](https://www.notion.so/2b566aece3f1482ab45a03e3546488d0)

[正则表达式 – 语法 | 菜鸟教程](https://www.runoob.com/regexp/regexp-syntax.html)

写复杂正则的一个常用方法，就是先把不相关的需求拆分开，分别写出对应的正则，然后组合，检一下相互的关联关系以及影响，基本上就可以得出对应的正则。

## 正则函数使用方法

### 判断是否匹配字符串

主要使用函数 re.match()

先看看如何判断正则表达式是否匹配：

    import re
    re.match(r'^\d{3}\-\d{3,8}$', '010-12345')
    <_sre.SRE_Match object; span=(0, 9), match='010-12345'>
    re.match(r'^\d{3}\-\d{3,8}$', '010 12345')
    >>>

`match()`方法判断是否匹配，如果匹配成功，返回一个`Match`对象，否则返回`None`。常见的判断方法就是：

    test = '010-12345'
    if re.match(r'\d{3}\-\d{3,8}', '010-12345'):
        print('OK')
    else:
        print('failed')

### 切分字符串

用正则表达式切分字符串比用固定的字符更灵活，主要使用函数 re.split()

    re.split(r'\s+','a  b c')

此部分看 cookbook 第二章有更详细的介绍

### 分组

除了简单的分组之外，正则表达式还有强大的提取子串的强大功能。用 `()` 表示的就是要提取的分组。

    m = re.match(r'^(\d{3})-(\d{3,8})$', '010-12345')
    m
    <_sre.SRE_Match object; span=(0, 9), match='010-12345'>
    m.group(0)
    '010-12345'
    m.group(1)
    '010'
    m.group(2)
    '12345'

如果正则表达式中定义了组，就可以在`Match`对象上用`group()`方法提取出子串来。

注意到`group(0)`永远是原始字符串，`group(1)`、`group(2)`……表示第1、2、……个子串。

## 贪婪匹配

正则默认是贪婪匹配，也就是匹配尽可能多的字符。

    re.match(r'(\d+)(0*)$', '102300').groups()
    ('102300', '')
    # 由于 \d+采取贪婪匹配，所以把后面的0全部匹配了，结果 0*只能匹配空字符了

加个`?` 就能让 \d+ 采用非贪婪匹配。

    re.match(r'(\d+?)(0*)$', '102300').groups()

## 编译

当我们在 Python 中使用正则表达式时，re模块内部会干两件事情：

- 编译正则表达式，如果正则表达式的字符串本身不合法，会报错。
- 用编译后的正则表达式去匹配字符串。

如果一个正则表达式要重复使用几千次，出于效率的考虑，我们可以预编译正则表达式，接下来重复使用就不用重复这个过程了，直接匹配。

其实就是把一个正则表达式赋值给一个变量

要用到 re.compile() 函数

    re_telephone = re.compile(r'^(\d{3})-(\d{3,8})$')

### re.match 和 re.search 的用法

search() vs match()

`search` ⇒ find something anywhere in the string and return a match object.

`match` ⇒ find something at the *beginning* of the string and return a match object.

在 search()下，用^，如果有分行符号则会匹配每一行的开头第一个字母，而 match 不会。
